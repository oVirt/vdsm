#
# Copyright 2009-2012 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Refer to the README and COPYING files for full details of the license
#
# Description: Deployment utilities.

import subprocess
import logging
import traceback
import socket
import re
import sys
import os
import os.path
import time
import datetime
import grp
import pwd
import shutil
from xml.sax import saxutils
import struct
import httplib
import glob
import imp
from optparse import OptionParser
import platform

try:
    from ovirtnode import ovirtfunctions
except ImportError:
    pass

# Path constants
P_BIN = '/bin/'
P_ETC_INITD = '/etc/init.d/'
P_LIB_SYSTEMD = '/lib/systemd/systemd-'
P_ROOT_SSH = pwd.getpwnam('root').pw_dir + '/.ssh'
P_ROOT_AUTH_KEYS = P_ROOT_SSH + '/authorized_keys'
P_VDSM_NODE_ID = '/etc/vdsm/vdsm.id'
P_SBIN = '/sbin/'
P_USR_BIN = '/usr/bin/'
P_USR_SBIN = '/usr/sbin/'
P_LIBEXEC = '/usr/libexec/'
_WORK_DIR = "/tmp"    # hardcoded as server use it as-is

# Executables
EX_CAT = '@CAT_PATH@'
EX_CHKCONFIG = '@CHKCONFIG_PATH@'
EX_DMIDECODE = '@DMIDECODE_PATH@'
EX_ECHO = '@ECHO_PATH@'
EX_GRUBBY = '@GRUBBY_PATH@'
EX_HWCLOCK = '@HWCLOCK_PATH@'
EX_IFCONFIG = '@IFCONFIG_PATH@'
EX_NTPQ = '@NTPQ_PATH@'
EX_OPENSSL = '@OPENSSL_PATH@'
EX_REBOOT = '@REBOOT_PATH@'
EX_RPM = '@RPM_PATH@'
EX_SED = '@SED_PATH@'
EX_SERVICE = '@SERVICE_PATH@'
EX_SYSTEMCTL = '@SYSTEMCTL_PATH@'
EX_YUM = '@YUM_PATH@'

# Other constants
VDSM_USER = "@VDSMUSER@"
VDSM_GROUP = "@VDSMGROUP@"
QEMU_GROUP = "@QEMUGROUP@"
READ_BUF_SIZE = 1024
DEF_KEY_LEN = 2048
HTTP_TIMEOUT = 30
ERR_NO_ROUTE = 7
SCRIPT_NAME_ADD = "addNetwork"
SCRIPT_NAME_DEL = "delNetwork"
IFACE_CONFIG = "/etc/sysconfig/network-scripts/ifcfg-"
MGT_BRIDGE_NAME = "@VDSMBRIDGE@"
REMOTE_SSH_KEY_FILE = ('/engine.ssh.key.txt',)
CORE_DUMP_PATH = '/var/lib/vdsm/core'
CORE_PATTERN = '/proc/sys/kernel/core_pattern'
XML_QUOTES = {
    "\n":' ',
    "'":'~'
}

# Regular expression used to validate content of SSH public keys:
SSH_PUBLIC_KEY_RE = re.compile(flags=re.VERBOSE, pattern=r"""
  ^
  \s*
  ssh-(rsa|dss)
  \s+
  ([A-Za-z0-9+/]+={0,2})
  (\s+[^\s]+)?
  \s*
  $
""")

#
# Script interface to use, required for
# multi-engine version support.
#
bootstrap_interface_version = 1

def isOvirt():
    """
        This function checks if current machine runs ovirt platform.
    """
    if os.path.exists('/etc/rhev-hypervisor-release'):
        return True
    elif not len(glob.glob('/etc/ovirt-node-*-release')) == 0:
        return True
    else:
        return False

def _logExec(argv, input=None):
    """
        This function executes a given shell command while logging it.
    """
    out = None
    err = None
    rc = None
    try:
        logging.debug(argv)
        stdin = None
        if input is not None:
            logging.debug(input)
            stdin = subprocess.PIPE
        p = subprocess.Popen(argv , stdin=stdin, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate(input)
        rc = p.returncode
        logging.debug(out)
        logging.debug(err)
    except:
        logging.error(traceback.format_exc())
    return (out, err, rc)

def vdsmImport(name, vdsmDir=None):
    # Legacy import for old vdsm packages
    if vdsmDir and vdsmDir not in sys.path:
        sys.path.append(vdsmDir)

    try:
        # Loading vdsm package
        fp, path, desc = imp.find_module("vdsm")
        vdsm = imp.load_module("vdsm", fp, path, desc)

        # Loading the module from the vdsm package
        fp, path, desc = imp.find_module(name, vdsm.__path__)
        imp_name = "vdsm." + name

    except ImportError:
        # Legacy import for old vdsm packages
        fp, path, desc = imp.find_module(name)
        imp_name = name

    try:
        return imp.load_module(imp_name, fp, path, desc)
    finally:
        # Since we may exit via an exception, close fp explicitly
        if fp:
            fp.close()

#############################################################################################################
# Host Misc functions.
#############################################################################################################
def escapeXML(message):
    """
        Escape '&', '<', '>', and '\n' in a given string.
    """
    return saxutils.escape(message, XML_QUOTES)

def simpleDaemon(main, args=(), kwargs={}):
    # Default maximum for the number of available file descriptors.
    MAXFD = 1024

    import resource  # Resource usage information.
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = MAXFD

    pid = os.fork()
    if pid == 0:
        try:
            os.setsid()
            for fd in range(0, maxfd):
                try:
                    os.close(fd)
                except OSError:  # ERROR, fd wasn't open to begin with (ignored)
                    pass

            os.open(os.devnull, os.O_RDWR)  # standard input (0)
            os.dup2(0, 1)  # standard output (1)
            os.dup2(0, 2)  # standard error (2)

            if os.fork() != 0:
                os._exit(0)

            main(*args, **kwargs)
        finally:
            os._exit(1)

    pid, status = os.waitpid(pid, 0)

    if not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
        raise RuntimeError("Daemon not exited properly")

def delayedReboot(sleepTime):
    time.sleep(sleepTime)
    os.execl(EX_REBOOT, EX_REBOOT)

def reboot():
    logging.debug("scheduling reboot")
    try:
        simpleDaemon(delayedReboot, args=(10,))
        return True
    except:
        logging.error("Could not reboot.", exc_info=True)
        return False

def setCoreDumpPath():
    logging.debug("setCoreDumpPath started.")
    fReturn = True
    try:
        _logExec([EX_ECHO, CORE_DUMP_PATH, ">", CORE_PATTERN])
        print "<BSTRAP component='CoreDump' status='OK'/>"
    except:
        fReturn = False
        print "<BSTRAP component='CoreDump' status='FAIL'/>"

    logging.debug("setCoreDumpPath end:" + str(fReturn))
    return fReturn

def _removeNoError(file):
    try:
        os.remove(file)
    except OSError:
        pass

def cleanAll(random_num):
    """ Remove temp files.
    """

    #
    # Old vds_installer.py did not cleanup after
    # running
    #
    if bootstrap_interface_version == 1:
        for f in (
            '/vds_bootstrap_%s.py' % random_num,
            '/vds_bootstrap_complete_%s.py' % random_num,
            '/deployUtil.py'
        ):
            _removeNoError(_WORK_DIR + f)
            _removeNoError(_WORK_DIR + f + "c")

    for f in (
        '/req_%s.conf' % random_num,
        '/cert_%s.req' % random_num,
        '/cert_%s.pem' % random_num,
        '/CA_%s.pem' % random_num,
        '/ovirt-id_rsa_%s' % random_num
    ):
        _removeNoError(_WORK_DIR + f)

    print "<BSTRAP component='cleanAll' status='OK'/>"
    logging.debug("cleanAll end")

    return True

def setVdsConf(configStr, confFile):
    """
        This function changes local configuration according to the
        given 'key=value;' string.
    """
    fReturn = True
    logging.debug("setVdsConf: started. config:" + str(configStr))
    if not configStr:
        logging.debug("setVdsConf: nothing to set.")
        return True

    if not os.path.exists(confFile):
        strMessage = escapeXML("File " + confFile + "does not exist.")
        print "<BSTRAP component='VDS Configuration' status='FAIL' message='" + strMessage + "'/>"
        logging.debug("setVdsConf: " + strMessage)
        return False

    try:
        new_config_params = {}
        config_params = configStr.split(';')
        for item in config_params:
            key = item.split('=')[0].strip()
            val = item.split('=')[1].strip()
            new_config_params[key] = val

        for key in new_config_params.keys():
            val = new_config_params[key]
            logging.debug("setVdsConf: setting Key=" + str(key) + " to val=" + str(val))
            _updateFileLine(confFile, key, val)
            #_logExec([EX_SED, "-i", "s:^\s*"+key+"\s*=.*:"+key+"="+val+":", confFile])

        if isOvirt():
            # save the updated file
            logging.debug("setVdsConf: saving new config file")
            ovirtfunctions.ovirt_store_config(confFile)

        print "<BSTRAP component='VDS Configuration' status='OK'/>"
    except Exception, e:
        msg = escapeXML(str(e))
        print "<BSTRAP component='VDS Configuration' status='FAIL' message='%s'/>" % (msg)
        logging.debug("setVdsConf: exception " + msg)
        fReturn = False

    logging.debug("setVdsConf: ended.")
    return fReturn

def getMachineUUID():
    """
        This function parses the DMI data for the host's UUID. If not found, returns "None".
    """
    arch = platform.machine()
    if arch == 'x86_64':
        out, err, ret = _logExec([EX_DMIDECODE, "-s", "system-uuid"])
        out = '\n'.join( line for line in out.splitlines()
                         if not line.startswith('#') )

        # Avoid error string- 'Not Settable' or 'Not Present'
        if ret == 0 and "Not" not in out:
            return out.replace ("\n", "")
    elif arch == "ppc64":
        if os.path.exists('/proc/device-tree/system-id'):
            #eg. output IBM,03061C14A
            return file('/proc/device-tree/system-id').readline().replace(",","")

    logging.error("getMachineUUID: Could not find machine's UUID.")

    return "None"

def getMacs():

    # (
    #     find /sys/class/net/*/device | while read f; do \
    #         cat "$(dirname "$f")/address"; \
    #     done; \
    #     [ -d /proc/net/bonding ] && \
    #         find /proc/net/bonding -type f -exec cat '{}' \; | \
    #         grep 'Permanent HW addr:' | \
    #         sed 's/.* //'
    # ) | sed -e '/00:00:00:00/d' -e '/^$/d'

    macs = []
    for b in glob.glob('/sys/class/net/*/device'):
        mac = file(os.path.join(os.path.dirname(b), "address")). \
            readline().replace("\n", "")
        macs.append(mac)

    for b in glob.glob('/proc/net/bonding/*'):
        for line in file(b):
            if line.startswith("Permanent HW addr: "):
                macs.append(line.split(": ")[1].replace("\n", ""))

    return set(macs) - set(["", "00:00:00:00:00:00"])

def getHostID():
    """
        This function concatenate the first serted mac address to the machine's UUID.
    """
    strReturn = "None"

    if os.path.exists(P_VDSM_NODE_ID):
        if isOvirt():
            ovirtfunctions.ovirt_store_config(P_VDSM_NODE_ID)
        with open(P_VDSM_NODE_ID) as f:
            strReturn = f.readline().replace("\n", "")
    else:
        strReturn = getMachineUUID()

        macs = getMacs()

        if len(macs) > 0:
            strMAC = sorted(macs)[0]
        else:
            strMAC = ""
            logging.warning("getHostID: Could not find machine's MAC, returning UUID only.")

        if strReturn != "None":
            strReturn += "_" + strMAC
        else:
            strReturn = "_" + strMAC

    logging.debug("getHostID: " + str(strReturn))
    return strReturn

def _getIfaceByIP(addr):
    remote = struct.unpack('I', socket.inet_aton(addr))[0]
    for line in file('/proc/net/route').readlines()[1:]:
        iface, dest, gateway, flags, refcnt, use, metric, \
            mask, mtu, window, irtt = line.split()
        dest = int(dest, 16)
        mask = int(mask, 16)
        if remote & mask == dest & mask:
            return iface

    return None # should never get here w/ default gw

def _getMGTIface(vdcHostName):
    strVDCIP = "None"
    strReturn = None
    strVDCName = vdcHostName

    try:
        if vdcHostName != "None":
            logging.debug("_getMGTIface: read host name: " + strVDCName)
            #Now find the IP. Note that gethostbyname(IP) == IP
            strVDCIP = socket.gethostbyname(strVDCName)
    except:
            strVDCIP = "None"
            logging.debug("_getMGTIface: error trying to figure out IP")

    logging.debug("_getMGTIface: using host name " + strVDCName + " strIP= " + strVDCIP)

    # Find the interface of the management IP
    if strVDCIP != "None":
        strReturn = _getIfaceByIP(strVDCIP)

    logging.debug("_getMGTIface IP=" + str(strVDCIP) + " strIface=" + str(strReturn))
    return strReturn

def getMGTIP(vdsmDir, vdcHostName):
    strReturn = "None"

    try:
        netinfo = vdsmImport("netinfo", vdsmDir)
    except:
        logging.error("getMGTIP: Failed to find vdsm modules!")
        return strReturn

    strIface = _getMGTIface(vdcHostName)

    if strIface is not None:
        strReturn = netinfo.getaddr(strIface)

    logging.debug("getMGTIP: Host MGT IP=" + strReturn)
    return strReturn

def preventDuplicate():
    """
      This function checks if the needed bridge (@VDSMBRIDGE@) already exist.
    """
    fFound = False

    if os.path.exists('/sys/class/net/' + MGT_BRIDGE_NAME):
        fFound = True
        logging.debug("Bridge " + MGT_BRIDGE_NAME + " already exists.")
    else:
        logging.debug("Bridge " + MGT_BRIDGE_NAME + " not found, need to create it.")

    return fFound

def getOSVersion():
    """
    Return the OS release, similarly to `lsb_release -rs`

    Return "Unknown OS" on any failure.
    """

    # platform.linux_distribution returns a tuple (distname, version, id) or
    # default as given in args in case of any failure
    osVer = platform.linux_distribution(distname='', version='Unknown OS')
    logging.debug("OS Release Ver = %s", osVer[1])
    return osVer[1]

def getKernelVR():
    """Return current kernel version and release."""

    components = os.uname()[2].split('-', 1)
    if len(components) == 2:
        return components
    else:
        return components[0], '0'

def compareVR(vr1, vr2):
    import rpmUtils.miscutils

    return rpmUtils.miscutils.compareEVR((0, vr1[0], vr1[1]),
                                         (0, vr2[0], vr2[1]))

def updateKernelArgs(arg):
    """
        Update current kernel arguments using grubby.
    """
    fReturn = False
    try:
        out, err, ret = _logExec([EX_GRUBBY, "--update-kernel",
                                    "DEFAULT", "--args", arg] )
        if not ret:
            fReturn = True
    except:
        pass

    return fReturn

def getAddress(url):
    logging.debug("getAddress Entry. url=" + str(url))
    import urlparse
    strRetAddress = None
    strRetPort = None
    scheme = None
    netloc = None
    path = None
    query = None
    fragment = None

    (scheme, netloc, path, query, fragment) = urlparse.urlsplit(url)
    if scheme != '':      #('http', 'www.redhat.com', '/rhel/virtualization/', '', '')
        strRetAddress = netloc
    elif path != '':      #('', '', 'www.redhat.com', '', '')
        strRetAddress = path
    else:
        logging.error("Unable to parse: " + str(url))

    # Find port
    if strRetAddress is not None and ":" in strRetAddress:
        strRetAddress, strRetPort = strRetAddress.split(":")

    logging.debug("getAddress return. address=" + str(strRetAddress) + " port=" + str(strRetPort))
    return strRetAddress, strRetPort

def waitRouteRestore(maxCount, targetIP):
    logging.debug("waitRouteRestore Entry. maxCount=" + str(maxCount) + " targetIP:" + targetIP)

    fReturn = True
    count = 0
    ret1 = ERR_NO_ROUTE #no route error code
    while(count<maxCount and ret1 == ERR_NO_ROUTE):
        try:
            out1, err1, ret1 = _logExec([
                '/usr/bin/curl',
                '-s',
                '--connect-timeout', '10',
                '--max-filesize', '10',
                targetIP
            ])
        except:
            pass

        count = count + 1
        logging.debug(
            " count=" + str(count-1) +
            "\nout=" + out1 +
            "\nerr=" + str(err1) +
            "\nret=" + str(ret1)
        )
        time.sleep(1)

    if ret1 == ERR_NO_ROUTE:
        fReturn = False

    logging.debug("waitRouteRestore Return. fReturn=" + str(fReturn))
    return fReturn

def setService(srvName, action):
    """
        Perform an action (stop/start/status/...) on a service
    """

    srvCtlName = srvName + ".service"

    nReturn = 0
    out = None
    err = None
    if type(srvName) == type(None):
        nReturn = 1
        message = "setService: ignoring None service."
        err = message
        logging.error(message)
    elif os.path.exists(P_ETC_INITD + srvName):
        out, err, nReturn = _logExec([EX_SERVICE, srvName, action])
    elif os.path.exists(P_LIB_SYSTEMD + srvName):
        out, err, nReturn = _logExec([EX_SYSTEMCTL, action, srvCtlName])
        # a hack until we have vdsm-tool to reconfigure Vdsm after installation
        EX_SYSTEMD_VDSMD = '/lib/systemd/systemd-vdsmd'
        if nReturn == 1 and srvName == 'vdsmd' \
                and err.startswith('Unknown operation'):
            out, err, nReturn = _logExec([EX_SYSTEMD_VDSMD, action])
    else:
        nReturn = 1
        err = "No such service: " + srvName

    return out, err, nReturn

def systemCtl(srvName, action, level=None):
    """
    Perform a set action (on/off/reset) on a systemd service
    """

    srvCtlName = srvName + ".service"

    if action == "off":
        out, err, nReturn = _logExec([EX_SYSTEMCTL, "is-enabled", srvCtlName])

        # Service not present or not enabled
        if nReturn != 0:
            return "", "", 0

        out, err, nReturn = _logExec([EX_SYSTEMCTL, "disable", srvCtlName])

    elif action == "on":
        out, err, nReturn = _logExec([EX_SYSTEMCTL, "enable", srvCtlName])

    elif action == "reset":
        raise Exception, \
                "The 'reset' action is not yet implemented for systemd"

    return out, err, nReturn

def chkConfig(srvName, action, level=None):
    """
    Perform a set action (on/off/reset) on an init script
    """
    if os.path.exists(EX_SYSTEMCTL):
        return systemCtl(srvName, action, level)

    nReturn = 0
    out = None
    err = None

    if os.path.exists(P_ETC_INITD + srvName):
        if level:
            out, err, nReturn = _logExec([EX_CHKCONFIG, '--level', level, srvName, action])
        else:
            out, err, nReturn = _logExec([EX_CHKCONFIG, srvName, action])
    else:
        if action != "off":
            nReturn = 1
            err = "No such service: " + srvName
        else:
            logging.debug("chkConfig: ignoring uninstalled service: " + str(srvName))

    return out, err, nReturn


#############################################################################################################
# Host SSH functions.
#############################################################################################################

def getAuthKeysFile(IP, port):
    """
        This functions returns the public ssh key of @ENGINENAME@.
    """
    _, _, engineWebCACert = certPaths('')
    data = None
    for key in REMOTE_SSH_KEY_FILE:
        tmp = getRemoteFile(IP, port, key,
                   timeout=HTTP_TIMEOUT, certPath=engineWebCACert)
        if tmp != None and validateSSHKey(tmp):
            data = tmp
            break

    return data

def addSSHKey(path, strKey):
    resKeys = []

    try:
        for key in file(path):
            if not key.endswith('\n'): # make sure we have complete lines
                key += '\n'
            if key != '\n' and not key.endswith(" ovirt-engine\n") or key.startswith("#"):
                resKeys.append(key)
    except IOError:
        logging.debug("Failed to read %s", path)
    if not strKey.endswith('\n'):
        strKey += '\n'
    resKeys.append(strKey)

    if isOvirt():
        # No problem to write to the original file here, since until it is not
        # persisted the old values are in place
        open(path, 'w').write(''.join(resKeys))
    else:
        tmpFilePath = path + '.tmp'
        open(tmpFilePath, 'w').write(''.join(resKeys))
        os.rename(tmpFilePath, path)

def silentRestoreCon(path):
    """silently ignore restorecon exceptios, when SELinux is disabled"""
    import selinux
    try:
        return selinux.restorecon(path)
    except:
        logging.error('restorecon %s failed', path, exc_info=True)

def validateSSHKey(strKey):
    """Check that the given string is a valid SSH public key"""
    if SSH_PUBLIC_KEY_RE.match(strKey) is None:
        logging.debug("validateSSHKey: the string \"%s\" is not a valid SSH key" % strKey)
        return False
    else:
        return True

def handleSSHKey(strKey):
    """
        This functions appends a given key to the root's authorized_keys file.
    """
    fReturn = True
    logging.debug('handleSSHKey start')
    if not os.path.exists(P_ROOT_SSH):
        logging.debug("handleSSHKey: creating .ssh dir.")
        try:
            os.mkdir(P_ROOT_SSH, 0700)
            silentRestoreCon(P_ROOT_SSH)
        except OSError:
            fReturn = False
            logging.debug("handleSSHKey: failed to create ssh dir!")

    if fReturn:
        try:
            addSSHKey(P_ROOT_AUTH_KEYS, strKey)
        except:
            fReturn = False
            logging.debug("handleSSHKey: failed to write authorized_keys!",
                          exc_info=True)

    if fReturn:
        try:
            os.chmod(P_ROOT_AUTH_KEYS, 0644)
            silentRestoreCon(P_ROOT_AUTH_KEYS)
        except:
            fReturn = False
            logging.debug("handleSSHKey: failed to chmod authorized_keys",
                          exc_info=True)

    if fReturn and isOvirt():
        # persist authorized_keys
        logging.debug("handleSSHKey: persist authorized_keys")
        ovirtfunctions.ovirt_store_config(P_ROOT_AUTH_KEYS)

    logging.debug('handleSSHKey end')
    return fReturn

#############################################################################################################
# Host time functions.
#############################################################################################################

def setHostTime(VDCTime):
    logging.debug('setHostTime start.')
    import time
    fReturn = True

    out, err, rc = _logExec([EX_NTPQ, "-c", "rv"])
    if out and 'clock_sync' in out:
        logging.debug("setHostTime: Time is synchronised to NTP server.")
    else:
        try:
            ttp = time.strptime(VDCTime, '%Y-%m-%dT%H:%M:%S')
        except ValueError, e:
            logging.debug("setHostTime: Failed to parse @ENGINENAME@ time. message= " + str(e))
            fReturn = False

        if fReturn:
            out, err, rc = _logExec([EX_HWCLOCK, "--set", "--utc",
                time.strftime('--date=%Y-%m-%d %H:%M:%S UTC', ttp)])
            if rc:
                logging.debug("setHostTime: Failed to set hwclock time. out=" + out + "\nerr=" + str(err) + "\nrc=" + str(rc))
                fReturn = False

        if fReturn:
            out, err, rc = _logExec([EX_HWCLOCK, "-s"])
            if rc:
                logging.debug("setHostTime: Failed to sync hwclock time to host. out=" + out + "\nerr=" + str(err) + "\nrc=" + str(rc))
                fReturn = False

    logging.debug('setHostTime end. Return:' + str(fReturn))
    return fReturn

#############################################################################################################
# Update configuration file functions.
#############################################################################################################

def _updateFileLine(fileName, key, value, insertIfMissing=False):
    """
        Update a line of a configuration file. This function will replace the whole line!
        The function returns success is replacment took place.
    """
    import stat
    from tempfile import mkstemp
    fReplaced = False
    logging.debug(
        "_updateFileLine: entry. File: " + str(fileName) +
        " key=" + str(key) +
        " value=" + str(value)
    )

    try:
        #Preserve current file mode
        mode = os.stat(fileName)[stat.ST_MODE]

        #Create temp file
        fh, abs_path = mkstemp()
        new_file = open(abs_path,'w')
        old_file = open(fileName)
        #Iterate over the existing file, while replacing if needed.
        for line in old_file:
            #Note: the line below must not have spaces before or after the '=', since it'll fail bash scripts !
            newLine = re.sub('^[#\s]*%s\s*=.*' % key , '%s=%s' % (key, value), line)
            if re.match('^%s=%s$' % (re.escape(key), re.escape(value)), newLine):
                logging.debug("_updateFileLine: replacing " + str(line) + " with: " + newLine)
                fReplaced = True
                line = newLine
            new_file.write(line)
        if insertIfMissing and not fReplaced:
            new_file.write("%s=%s\n" % (key, value))
            fReplaced = True
        new_file.close()
        os.close(fh)
        old_file.close()
        #Move new file
        shutil.move(abs_path, fileName)

        #Restore original file mode
        os.chmod(fileName, mode)
    except:
        try:
            old_file.close()
        except:
            pass
        logging.error("_updateFileLine: error replacing " + str(key) + "=" + str(value))
        logging.error(traceback.format_exc())

    logging.debug("_updateFileLine: return: " + str(fReplaced))
    return fReplaced

#############################################################################################################
# Host bridge functions.
#############################################################################################################

def _getBridgeParams(bridgeName):
    import shlex

    fIsBridgeDevice = False
    lstReturn = []
    fileName = IFACE_CONFIG + bridgeName

    try:
        for line in file(fileName):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            elif line.startswith("DEVICE=") or line.startswith("HWADDR="):
                continue
            elif line.startswith("NM_CONTROLLED="):
                continue
            elif line.startswith("TYPE="):
                t = line.split("=", 1)[1].strip()
                fIsBridgeDevice = (t == "Bridge")
            else:
                try:
                    line = ''.join(shlex.split(line))
                except:
                    logging.warn("_getBridgeParams: failed to read parse line %s", line)
                lstReturn.append(line)
    except Exception, e:
        logging.error("_getBridgeParams: failed to read params of file " + fileName + ".\n Error:" + str(e))
        lstReturn = []

    return lstReturn, fIsBridgeDevice

def _getOvirtBridgeParams(mgtBridge):
    """
        This helper function extract the relevant parameters of the existing
        ovirt bridge in order to re-create it as a managment bridge.
    """
    netinfo = vdsmImport("netinfo")

    vlan = ''
    bonding = ''
    nic = None
    nics = []

    try:
        vlan, bonding, nics = netinfo.getVlanBondingNic(mgtBridge)
        nic = nics[0]
    except:
        nic = None
        logging.error("_getOvirtBridgeParams Failed to get bridge data:")
        logging.error(traceback.format_exc())

    return vlan, bonding, nic

def _getRHELBridgeParams(mgtIface):
    """
        This helper function extract the relevant parameters of the existing
        RHEL interface, in order to create a managment bridge.
    """
    netinfo = vdsmImport("netinfo")

    vlan = ''
    bonding = ''
    nic = None

    try:
        vlans = netinfo.vlans()
        if mgtIface in vlans:
            nic = netinfo.getVlanDevice(mgtIface)
            vlan = netinfo.getVlanID(mgtIface)
        else:
            nic = mgtIface

        if nic in netinfo.bondings():
            logging.error("_getRHELBridgeParams Found bonding: " + str(nic) + \
               ". This network configuration is not" \
                "supported! Please configure " + MGT_BRIDGE_NAME + " bridge manually and re-install.")
            nic = None
    except:
        logging.error("_getRHELBridgeParams Failed to test for VLAN data")
        logging.error(traceback.format_exc())
        nic = None

    return vlan, bonding, nic

def setSafeVdsmNetworkConfig():
    """consider current network configuration as safe and remove its backup"""
    if versionCompare(getOSVersion(), "6.0") < 0:
        shutil.rmtree("/etc/sysconfig/network-scripts/.vdsmback")
    else:
        import glob
        for f in glob.glob("/var/lib/vdsm/netconfback/*"):
            if os.path.isdir(f):
                shutil.rmtree(f)
            else:
                os.remove(f)


def makeBridge(vdcName, vdsmDir):
    """
        Create (for RHEL) or rename (oVirt default bridge) to @VDSMBRIDGE@ bridge.
    """
    logging.debug('makeBridge begin.')

    try:
        vdsmImport("netinfo", vdsmDir)
    except ImportError:
        logging.error("makeBridge Failed to find vdsm modules!")
        return False

    fReturn = True
    out = ""
    err = None
    ret = None
    nic = None
    fIsOvirt = isOvirt()

    # get current management interface
    mgtIface = _getMGTIface(vdcName)
    if mgtIface is None:
        fReturn = False
        logging.debug("makeBridge got mgtIface None. This is a routing or resolution issue.")
    else:
        mgtBridge = mgtIface
        if fIsOvirt and mgtIface.startswith('br'):
            mgtIface = mgtIface.replace("br", "", 1) #oVirt naming convention: br + iface

    if fReturn:
        # Read params from current bridge (bootproto, etc)
        Iface = mgtIface
        if fIsOvirt: Iface = mgtBridge
        lstBridgeOptions, fIsBridgeDevice = _getBridgeParams(Iface)

        if len(lstBridgeOptions) == 0:
            logging.error("makeBridge Failed to read existing nic parameters")
            fReturn = False
        elif fIsBridgeDevice and not fIsOvirt:
            logging.error("makeBridge found existing bridge named: " + Iface)
            fReturn = False
        else:
            logging.debug("makeBridge found the following bridge paramaters: " + str(lstBridgeOptions))
            # No more handling GATEWAYDEV.

    if fReturn:
        if fIsOvirt:
            vlan, bonding, nic = _getOvirtBridgeParams(mgtBridge)
        else:
            vlan, bonding, nic = _getRHELBridgeParams(mgtIface)
        fReturn = (nic is not None)

    #Delete existing bridge in oVirt
    if fReturn and fIsOvirt:
        try:
            out, err, ret = _logExec([os.path.join(vdsmDir, SCRIPT_NAME_DEL), mgtBridge, vlan, bonding, nic])
            if ret:
                if ret == 17: #ERR_BAD_BRIDGE
                    logging.debug("makeBridge Ignoring error of del existing bridge. out=" + out + "\nerr=" + str(err) + "\nret=" + str(ret))
                else:
                    fReturn = False
                    logging.debug("makeBridge Failed to del existing bridge. out=" + out + "\nerr=" + str(err) + "\nret=" + str(ret))
            else:
                ovirtfunctions.ovirt_safe_delete_config(IFACE_CONFIG + mgtBridge)
        except:
            fReturn = False
            logging.debug("makeBridge Failed to del existing bridge. out=" + out + "\nerr=" + str(err) + "\nret=" + str(ret))

    #Add @VDSMBRIDGE@ bridge
    if fReturn:
        try:
            lstBridgeOptions.append('blockingdhcp=true')
            out, err, ret = _logExec([os.path.join(vdsmDir, SCRIPT_NAME_ADD) , MGT_BRIDGE_NAME, vlan, bonding, nic] + lstBridgeOptions)
            if ret:
                fReturn = False
                logging.debug("makeBridge Failed to add " + MGT_BRIDGE_NAME + " bridge out=" + out + "\nerr=" + str(err) + "\nret=" + str(ret))
        except:
            fReturn = False
            logging.debug("makeBridge Failed to add " + MGT_BRIDGE_NAME + " bridge out=" + out + "\nerr=" + str(err) + "\nret=" + str(ret))

    #Save current config by removing the undo files:
    try:
        if fReturn and not fIsOvirt:
            setSafeVdsmNetworkConfig()
    except:
        logging.debug(traceback.format_exc())

    if not fReturn:
        logging.error(
            "makeBridge errored: " +
            " out=" + out +
            "\nerr=" + str(err) +
            "\nret=" + str(ret)
        )

    logging.debug('makeBridge return.')
    return fReturn

#############################################################################################################
# Host package / rpm functions.
#############################################################################################################

def getPackageInfo(pckg_type, rpm_name, op):
    """
        Return an indication if given package name is installed or not.
    """
    strReturn = "FAIL"
    out, err, rc = _logExec([EX_RPM, "-q", rpm_name])
    if rc:
        if op == 'install':
            if pckg_type != "DEVEL":
                strReturn = "FAIL"
                out += err
            else:
                strReturn = "WARN"
        else:
            strReturn = "WARN"
    else:
        strReturn = "OK"

    return strReturn, out

def versionCompare(pkg1, pkg2):
    """
        Return an indication if given package1 is:
        -1: pkg1 < pkg2
        0: pkg1 == pkg2
        1: pkg1 > pkg2
        99 import Exception
    """
    nReturn = 0

    try:
        import rpmUtils
        import rpmUtils.miscutils
    except:
        nReturn = 99

    if nReturn == 0:
        nReturn = rpmUtils.miscutils.compareEVR(
            rpmUtils.miscutils.stringToVersion(pkg1),
            rpmUtils.miscutils.stringToVersion(pkg2)
        )

    return nReturn

def yumCleanCache():
    """
        Make sure that yum cache is valid. This function makes yum revalidate
        the cache for each repo next time it is used.
    """
    fReturn = False
    out, err, ret = _logExec([EX_YUM, "clean", "expire-cache"] )
    if not ret:
        fReturn = True

    return fReturn

def yumInstallDeleteUpdate(pckgName, action, args=None):
    """
        Call yum to install, delete or update a given package name.
    """
    execFunc = [EX_YUM, "-y"]
    if args is not None:
        execFunc += args

    if action == "install":
        execFunc.append(action)
    elif action == "remove":
        execFunc.append(action)
    else:
        execFunc.append("update")
    execFunc.append(pckgName)

    return _logExec(execFunc)

def installAndVerify(pckgType, pckgName, action, args=None):
    """
        This function uses other module functions to install or update
        a package, and then verify it.
    """
    fReturn = True
    out, err, ret = yumInstallDeleteUpdate(pckgName, action, args=None)
    msg = None
    if not ret:
        fReturn, msg = getPackageInfo(pckgType, pckgName, 'install')
    else:
        fReturn = False
        msg = out + err

    return fReturn, msg

def yumListPackages(pkgName):
    """
        Returns a list of available packages exists in yum's db.
    """
    import yum

    my = yum.YumBase()
    my.preconf.debuglevel = 0 # Remove yum noise
    return my.pkgSack.searchNevra(name=pkgName)

def yumSearchVersion(pkgName, ver):
    "Return True if package exists in yum's db with the given version or higer"
    import rpmUtils.miscutils

    for pkg in yumListPackages(pkgName):
        if rpmUtils.miscutils.compareEVR(('', pkg.ver, ''),
                                         ('', ver, '')) >= 0:
            return True
    else:
        return False

#############################################################################################################
# Host PKI functions.
#############################################################################################################

def validateX509Cert(strCert):
    """Validates a PEM encoded X.509 digital certificate"""
    out, err, rc = _logExec([EX_OPENSSL, "x509", "-noout"], input=strCert)
    if rc != 0:
        logging.debug("validateX509Cert: the string \"%s\" is not a valid X.509 certificate", strCert)
        return False
    else:
        return True

def _tsDir(confFile):
    import ConfigParser

    config = ConfigParser.ConfigParser()
    config.read(confFile)
    try:
        tsDir = config.get('vars', 'trust_store_path')
    except:
        tsDir = '/etc/pki/vdsm'
    return tsDir

def certPaths(confFile, fAddID=False):
    tsDir = _tsDir(confFile)

    VDSMCERT = tsDir + "/certs/vdsmcert.pem"
    if fAddID:
        VDSMCERT = tsDir + "/certs/vdsm-" + os.environ.get("SSH_CONNECTION").split()[2] + "-cert.pem"
    CACERT = tsDir + "/certs/cacert.pem"
    engineWebCACert = tsDir + "/certs/engine_web_ca.pem"

    return CACERT, VDSMCERT, engineWebCACert

def pkiCleanup(key, cert):
    """
        Removes all the previously installed keys and certificates
    """
    if os.path.exists(key):
        if isOvirt():
            ovirtfunctions.ovirt_safe_delete_config(key)
        else:
            os.unlink(key)

    if os.path.exists(cert):
        if isOvirt():
            ovirtfunctions.ovirt_safe_delete_config(cert)
        else:
            os.unlink(cert)

def _linkOrPersist(src, dst):
    # we have to copy the key and cert since ovirt currently cannot persist
    # softlinks
    if isOvirt():
        shutil.copy2(src, dst)
        st = os.stat(src)
        os.chown(dst, st.st_uid, st.st_gid)
        ovirtfunctions.ovirt_store_config(dst)
    else:
        try:
            os.unlink(dst)
        except:
            pass
        os.symlink(src, dst)

def instCert(random_num, confFile):
    """ Install certificate.
    """
    fReturn = True

    try:
        logging.debug("instCert: start. num=" + str(random_num))
        # build semi-random filenames
        cert_pemfile = _WORK_DIR + '/cert_' + random_num + '.pem'
        ca_pemfile = _WORK_DIR + '/CA_' + random_num + '.pem'
        gGroup = grp.getgrnam(VDSM_GROUP)
        nGID = gGroup.gr_gid
        uUserInfo = pwd.getpwnam(VDSM_USER)
        nUID = uUserInfo.pw_uid
        CACERT, VDSMCERT, engineWebCACert = certPaths(confFile)

        # Delete old certificates
        logging.debug("instCert: try to delete old certificates")
        pkiCleanup(VDSMCERT, CACERT)

        logging.debug("instCert: install new certificates")
        # install .pem files
        shutil.copy(cert_pemfile, VDSMCERT)
        os.chown (VDSMCERT, nUID, nGID)
        os.chmod (VDSMCERT, 0444)
        if not os.path.exists(CACERT):
            shutil.copy(ca_pemfile, CACERT)
        os.chown (CACERT, nUID, nGID)
        os.chmod (CACERT, 0444)

        if isOvirt():
            # save the certificates
            logging.debug("instCert: persist new certificates")
            ovirtfunctions.ovirt_store_config(VDSMCERT)
            ovirtfunctions.ovirt_store_config(CACERT)

        ts = _tsDir(confFile)
        VDSMKEY = ts + '/keys/vdsmkey.pem'
        SPICEPKIPATH = os.path.join(ts, 'libvirt-spice')

        try:
            os.makedirs(SPICEPKIPATH)
        except OSError, e:
            if e.errno != os.errno.EEXIST:
                raise

        os.chown(SPICEPKIPATH, 0, nGID)
        os.chmod(SPICEPKIPATH, 0750)

        _linkOrPersist(CACERT, ts + '/libvirt-spice/ca-cert.pem')
        _linkOrPersist(VDSMCERT, ts + '/libvirt-spice/server-cert.pem')
        _linkOrPersist(VDSMKEY, ts + '/libvirt-spice/server-key.pem')
        if not os.path.exists('/etc/pki/libvirt/private'):
            os.makedirs('/etc/pki/libvirt/private')
        _linkOrPersist(VDSMCERT, '/etc/pki/libvirt/clientcert.pem')
        _linkOrPersist(VDSMKEY, '/etc/pki/libvirt/private/clientkey.pem')
        _linkOrPersist(CACERT, '/etc/pki/CA/cacert.pem')

        print "<BSTRAP component='instCert' status='OK'/>"
        logging.debug("instCert: ended.")
    except:
        fReturn = False
        logging.debug("instCert: failed.", exc_info=True)
        print "<BSTRAP component='instCert' status='FAIL'/>"

    return fReturn

def getSSLSocket(sock, certPath=None):
    """
        Returns ssl socket according to python version
    """
    try:
        import ssl
        if not certPath:
            return ssl.wrap_socket(sock)
        else:
            return ssl.wrap_socket(sock, ca_certs=certPath,
                                   cert_reqs=ssl.CERT_REQUIRED)
    except ImportError:
        # in python 2.4 importing ssl will fail
        ssl = socket.ssl(sock)
        return httplib.FakeSocket(sock, ssl)

def createCSR(orgName, subject, random_num, tsDir, vdsmKey):
    template = """
    RANDFILE               = ~/.rnd
    [ req ]
    distinguished_name     = req_distinguished_name
    prompt                 = no
    [ v3_ca ]
    subjectKeyIdentifier=hash
    authorityKeyIdentifier=keyid:always,issuer:always
    basicConstraints = CA:true
    [ req_distinguished_name ]
    O = %s
    CN = %s
    """ % (repr(orgName), subject)

    req_conffile = _WORK_DIR + '/req_' + random_num + '.conf'
    cert_reqfile = _WORK_DIR + '/cert_' + random_num + '.req'
    open(req_conffile, "w").write(template)

    if not os.path.exists(tsDir + "/keys"):
        os.mkdir(tsDir + "/keys")

    if not os.path.exists(tsDir + "/certs"):
        os.mkdir(tsDir + "/certs")

    # create private key
    _logExec([EX_OPENSSL, "genrsa", "-out", vdsmKey, str(DEF_KEY_LEN)])
    # create request for certificate
    execfn = [EX_OPENSSL, "req", "-new", "-key", vdsmKey,
                "-config", req_conffile, "-out", cert_reqfile]
    _logExec(execfn)
    if versionCompare(getOSVersion(), "6.0") < 0:
        gGroup = grp.getgrnam(VDSM_GROUP)
    else:
        gGroup = grp.getgrnam(QEMU_GROUP)
    nGID = gGroup.gr_gid
    uUserInfo = pwd.getpwnam(VDSM_USER)
    nUID = uUserInfo.pw_uid
    os.chown (vdsmKey, nUID, nGID)
    os.chmod (vdsmKey, 0440)

    if isOvirt():
        # save the certificates
        ovirtfunctions.ovirt_store_config(vdsmKey)

def _cpuid(func):
    f = file('/dev/cpu/0/cpuid')
    f.seek(func)
    return struct.unpack('IIII', f.read(16))

def _prdmsr(cpu, index):
    f = file("/dev/cpu/%d/msr" % cpu)
    f.seek(index)
    try:
        return struct.unpack('L', f.read(8))[0]
    except:
        return -1

def _cpu_has_vmx_support():
    eax, ebx, ecx, edx = _cpuid(1)
    # CPUID.1:ECX.VMX[bit 5] -> VT
    return ecx & (1 << 5) != 0

def _vmx_enabled_by_bios():
    MSR_IA32_FEATURE_CONTROL = 0x3a
    MSR_IA32_FEATURE_CONTROL_LOCKED = 0x1
    MSR_IA32_FEATURE_CONTROL_VMXON_ENABLED = 0x4

    msr = _prdmsr(0, MSR_IA32_FEATURE_CONTROL);
    return (msr & (MSR_IA32_FEATURE_CONTROL_LOCKED |
                   MSR_IA32_FEATURE_CONTROL_VMXON_ENABLED)) != MSR_IA32_FEATURE_CONTROL_LOCKED

def _cpu_has_svm_support():
    SVM_CPUID_FEATURE_SHIFT = 2
    SVM_CPUID_FUNC = 0x8000000a

    eax, ebx, ecx, edx = _cpuid(0x80000000)
    if eax < SVM_CPUID_FUNC:
        return 0

    eax, ebx, ecx, edx = _cpuid(0x80000001)
    if not (ecx & (1 << SVM_CPUID_FEATURE_SHIFT)):
        return 0
    return 1

def _svm_enabled_by_bios():
    SVM_VM_CR_SVM_DISABLE = 4
    MSR_VM_CR = 0xc0010114

    vm_cr = _prdmsr(0, MSR_VM_CR)
    if vm_cr & (1 << SVM_VM_CR_SVM_DISABLE):
        return 0
    return 1


def _check_kvm_support_on_power():
    for line in file('/proc/cpuinfo').readlines():
        if ':' in line:
            k, v = line.split(':', 1)
            k = k.strip()
            v = v.strip()
        if k == 'platform':
            if 'powernv' in v.lower():
                return 1

    return 0


def cpuVendorID():
    for line in file('/proc/cpuinfo').readlines():
        if ':' in line:
            k, v = line.split(':', 1)
            k = k.strip()
            v = v.strip()
        if k == 'vendor_id' or k == 'cpu':
            if v == 'GenuineIntel':
                return v
            elif v == 'AuthenticAMD':
                return v
            elif 'power' in v.lower():
                return 'IBM_POWER'
    return ''

def virtEnabledInCpuAndBios():
    try:
        vendor = cpuVendorID()
        logging.debug('CPU vendor is %s', vendor)

        if vendor == 'GenuineIntel':
            bios_en = _vmx_enabled_by_bios()
            has_cpu = _cpu_has_vmx_support();
        elif vendor == 'AuthenticAMD':
            bios_en = _svm_enabled_by_bios();
            has_cpu = _cpu_has_svm_support();
        elif vendor == 'IBM_POWER':
            if _check_kvm_support_on_power():
                bios_en = 1;
                has_cpu = 1;
        else:
            return False

        logging.debug('virt support in cpu: %s, in bios: %s', has_cpu, bios_en)
        return bios_en and has_cpu
    except:
        logging.error(traceback.format_exc())
        return False

def getRemoteFile(IP, port, fileName, timeout=None, certPath=None):
    logging.debug("getRemoteFile start. IP = %s port = %s fileName = \"%s\""
            % (IP, port, fileName))
    data = None
    response = None
    conn = None
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    fOK = True

    try:
        nPort = 443
        if port is not None:
            nPort = int(port)

        sock.connect((IP, nPort))
        conn = httplib.HTTPSConnection(IP, nPort)
        conn.sock = getSSLSocket(sock, certPath)
        conn.request("GET", fileName)
        response = conn.getresponse()
    except:
        logging.debug("%s failed in HTTPS. Retrying using HTTP.", fileName,
                exc_info=True)
        strPort = ":"
        if port is None:
            strPort += "80"
        else:
            strPort += port

        try:
            conn = httplib.HTTPConnection(IP + strPort)
            conn.request("GET", fileName)
            response = conn.getresponse()
        except:
            logging.error("Failed to fetch %s using http.", fileName,
                    exc_info=True)
            fOK = False
    else:
        logging.debug("%s status: %s reason: %s",
                      fileName, str(response.status), response.reason)

    if response == None or response.status != 200:
        status = ""
        if response != None:
            status = str(response.status)
        if conn != None: conn.close()
        fOK = False
        logging.error("Failed to fetch %s status %s", fileName, status)

    if fOK:
        try:
            try:
                data = str(response.read())
            except:
                logging.error("Failed to read %s", fileName, exc_info=True)
        finally:
            if conn != None: conn.close()

    logging.debug('getRemoteFile end.')
    return data

def _nodeBackupCerts(certs):
    dt = datetime.datetime.now()
    backupTime = dt.strftime("%Y-%m-%d_%H%M%S")

    for pemFile in certs:
        if os.path.exists(pemFile):
            certName = os.path.basename(pemFile)
            dirName  = os.path.dirname(pemFile)

            bkpCertName = dirName + "/bkp-" + backupTime + '_' + certName

            shutil.copy2(pemFile, bkpCertName)
            st = os.stat(pemFile)
            os.chown(bkpCertName, st.st_uid, st.st_gid)
            ovirtfunctions.ovirt_store_config(bkpCertName)

def nodeCleanup():
    if isOvirt():
        CACERT, VDSMCERT, engineWebCACert = certPaths('')

        _nodeBackupCerts([CACERT, VDSMCERT, engineWebCACert])
        if os.path.exists(engineWebCACert):
            ovirtfunctions.ovirt_safe_delete_config(engineWebCACert)

def getRhevmCert(IP, port):
    """Download the certificate of the CA of the engine web server.

    This certificate is saved to a file and later used
    to validate HTTPS connections with the engine web
    server.

    """
    _, _, engineWebCACert = certPaths('')
    RHEVM_CERT_FILE = "/ca.crt"
    rhevmCert = getRemoteFile(str(IP), str(port), RHEVM_CERT_FILE)
    if rhevmCert and validateX509Cert(rhevmCert):
        dirName = os.path.dirname(engineWebCACert)
        if not os.path.exists(dirName):
            os.makedirs(dirName)
        crt = file(engineWebCACert, "w+")
        try:
            crt.write(rhevmCert)
        finally:
            crt.close()
        return True
    else:
        return False

def generateFingerPrint(path):
    fp = ''
    cmd = [EX_OPENSSL, 'x509', '-fingerprint', '-in', path]
    out, err, rc = _logExec(cmd)
    if rc is 0:
        try:
            fp = filter(lambda l: 'Fingerprint' in l, out.split())[0].split('=')[1]
        except Exception:
            logging.error("Failed generating finger print for %s", path,
                    exc_info=True)
    else:
        logging.error("Command %s failed with return value %d",
                      ' '.join(cmd), rc)

    return fp

def parseOptions():
    parser = OptionParser()

    parser.add_option("-s", "--server-address",
        action="store", dest="serverIp", type="string", default=None,
        help="IP address of @ENGINENAME@")
    parser.add_option("-p", "--server-port",
        action="store", dest="serverPort", default=None, type="string",
        help="Port of @ENGINENAME@")

    parser.add_option("-d", "--download-rhevm-cert", action="store_true",
                      default=False, dest="downloadRhevmCert",
                      help="Download certificate from @ENGINENAME@")
    parser.add_option("-f", "--fingerprint", action="store",
            dest="fingerPrint", default=None, type="string",
            help="""
            The fingerprint to compare to the fingerprint of the downloaded
            certificate""")

    parser.add_option("-c", "--node-cleanup", action="store_true",
                      default=False, dest="nodeCleanup",
                      help="Clean node from possible past residuals")

    options, args = parser.parse_args()

    return (options, args)

def main():
    options, args = parseOptions()

    if options.nodeCleanup:
        nodeCleanup()
        print 'Node clean-up successful'
        return 0
    if options.downloadRhevmCert:
        if not options.serverIp or not options.serverPort or \
                not options.fingerPrint:
            print "Must supply @ENGINENAME@'s IP, port and a fingerprint to " + \
                  "verify against"
            return -1
        if not getRhevmCert(options.serverIp, options.serverPort):
            print 'Failed downloading the @ENGINENAME@ certificate file'
            return -1
        _, _, engineWebCACert = certPaths('')
        fp = generateFingerPrint(engineWebCACert)
        if options.fingerPrint != fp:
            print 'Expected fingerprint %s is different from recieved fingerprint %s' % (options.fingerPrint, fp)
            return -1

        if isOvirt():
            ovirtfunctions.ovirt_store_config(engineWebCACert)
        print '@ENGINENAME@ certificate downloaded and verified successfully.'
        return 0
    print 'Missing arguments'
    return -1

def getBootstrapInterfaceVersion():
    return bootstrap_interface_version

def setBootstrapInterfaceVersion(v):
    global bootstrap_interface_version
    bootstrap_interface_version = v

if __name__ == '__main__':
    sys.exit(main())
